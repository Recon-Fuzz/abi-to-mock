// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract {{contractName}} {
    {{#each structs}}
    // Struct definition for {{name}}
    struct {{name}} {
        {{#each fields}}
        {{type}} {{name}};
        {{/each}}
    }
    {{/each}}

    {{#each functions}}
    // Storage for {{name}} return values
    {{#each outputs}}
    {{processType this}} private _{{../name}}Return_{{@index}};
    {{/each}}

    // Function to set return values for {{name}}
    function set{{capitalize name}}Return({{#each outputs}}{{processType this}}{{memoryKeyword (processType this)}} _value{{@index}}{{#unless @last}}, {{/unless}}{{/each}}) public {
        {{#each outputs}}
        {{#if (isArrayType (processType this))}}
        delete _{{../name}}Return_{{@index}};
        {{#if (isMultiArray (processType this))}}
        {{#if (isFixedArray (processType this))}}
        for(uint i = 0; i < {{getFixedArrayLength (processType this)}}; i++) {
            for(uint j = 0; j < _value{{@index}}[i].length; j++) {
                _{{../name}}Return_{{@index}}[i][j] = _value{{@index}}[i][j];
            }
        }
        {{else}}
        for(uint i = 0; i < _value{{@index}}.length; i++) {
            _{{../name}}Return_{{@index}}.push();
            for(uint j = 0; j < _value{{@index}}[i].length; j++) {
                _{{../name}}Return_{{@index}}[i].push(_value{{@index}}[i][j]);
            }
        }
        {{/if}}
        {{else}}
        {{#if (isFixedArray (processType this))}}
        for(uint i = 0; i < {{getFixedArrayLength (processType this)}}; i++) {
            _{{../name}}Return_{{@index}}[i] = _value{{@index}}[i];
        }
        {{else}}
        for(uint i = 0; i < _value{{@index}}.length; i++) {
            _{{../name}}Return_{{@index}}.push(_value{{@index}}[i]);
        }
        {{/if}}
        {{/if}}
        {{else}}
        _{{../name}}Return_{{@index}} = _value{{@index}};
        {{/if}}
        {{/each}}
    }

    // Mock implementation of {{name}}
    function {{name}}({{#each inputs}}{{processType this}}{{#if (isStruct (processType this))}} memory{{/if}} {{#if name}}{{name}}{{else}}arg{{@index}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}})
        public
        {{#if outputs}}returns ({{#each outputs}}{{processType this}}{{#if (isStruct (processType this))}} memory{{/if}}{{#unless @last}}, {{/unless}}{{/each}}){{/if}}
    {
        {{#if outputs}}
        {{#if (hasMultipleOutputs outputs)}}
        return ({{#each outputs}}_{{../name}}Return_{{@index}}{{#unless @last}}, {{/unless}}{{/each}});
        {{else}}
        return _{{name}}Return_0;
        {{/if}}
        {{/if}}
    }

    {{#each outputs}}
    {{#if (isArrayType (processType this))}}
    // Individual element getter for {{../name}}
    function {{../name}}Element(uint i{{#if (isMultiArray (processType this))}}, uint j{{/if}})
        public
        returns ({{getElementType (processType this)}}{{#if (isStructElementType (processType this))}} memory{{/if}})
    {
        {{#if (isMultiArray (processType this))}}
        return _{{../name}}Return_{{@index}}[i][j];
        {{else}}
        return _{{../name}}Return_{{@index}}[i];
        {{/if}}
    }
    {{/if}}
    {{/each}}

    {{/each}}

    {{#each events}}
    // Event declaration
    event {{name}}({{#each inputs}}{{processType this}} {{#if name}}{{name}}{{else}}arg{{@index}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}});

    // Function to emit {{name}} event
    function emit{{name}}({{#each inputs}}{{processType this}}{{memoryKeyword (processType this)}} {{#if name}}{{name}}{{else}}arg{{@index}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}}) public {
        emit {{name}}({{#each inputs}}{{#if name}}{{name}}{{else}}arg{{@index}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}});
    }
    {{/each}}
}
